#!/usr/bin/env python3
# encoding: utf-8
# SPDX-FileCopyrightText: 2023 past-due <https://github.com/past-due>
# SPDX-License-Identifier: GPL-2.0-or-later

import subprocess
import json
import os
import sys
import time
import argparse
import hashlib
import shutil
import re
import zipfile
import jwt # PyJWT
import requests
from enum import IntEnum
from datetime import timezone, datetime
from collections import OrderedDict
from urllib.parse import urlparse, urlunparse
from distutils.dir_util import copy_tree
from pathlib import Path
from funcs.gen_map_info import MapRepoExternalTools, generate_map_preview_png
from funcs.dry_run_wrappers import subprocess_run_modification_cmd_wrapper
from funcs.gh_app_token_provider import WZGithubAppTokenProvider
from validate_new_map import validate_map, FailedToProcessMapError, MapReposConfig, MapValidationDetails, path_exists_case_insensitive, MapNameUniquenessCheck

GH_REST_API_VERSION = '2022-11-28'

WZ_EXPECTED_VALIDATION_COMMENT_AUTHORS = [{
    'login': 'github-actions[bot]',
    'id': 41898282,
},
    {
        'login': 'past-due',
        'id': 30942300,
    },
]

class WZGitHubMapSubmissionDetails:
    def __init__(self, gh_issue_number: int, map_attachment_url: str, description_body: str | None):
        self.gh_issue_number = gh_issue_number
        self.map_attachment_url = map_attachment_url
        self.description_body = description_body
    
    def update_description_from_followup_comment(self, gh_comment_id: int, new_description_body: str):
        self.description_body = new_description_body
        
    def update_map_attachment_from_followup_comment(self, gh_comment_id: int, new_map_attachment_url: str):
        self.map_attachment_url = new_map_attachment_url
        

def get_dl_filename_from_url(url: str) -> str | None:
    split_dl_url = urlparse(url)
    if not split_dl_url.path:
        return None
    return Path(split_dl_url.path).name

def dl_gh_attachment(url: str, gh_repo: str, output_path: Path) -> dict:
    total_dl_size = 0
    sha512_hash = hashlib.sha512()
    
    # Verify expected issue attachment url format / location
    split_dl_url = urlparse(url)
    # -  url domain ends with [\.]?github.com
    if not re.match(r'^(?:.*\.)?github.com(?:\:.*)?$', split_dl_url.netloc):
        raise ValueError('Unexpected GitHub attachment URL: {0}'.format(url))
    # - path begins with: {gh_repo}/files/
    if not re.match(r'^[/]?{0}/files/'.format(gh_repo), split_dl_url.path):
        raise ValueError('Unexpected GitHub attachment URL path: {0}'.format(url))
    
    with requests.get(url, stream=True) as r:
        r.raise_for_status()
        with open(output_path, 'wb') as f:
            for chunk in r.iter_content(chunk_size=8*1024): 
                if not chunk:
                    continue
                
                total_dl_size += len(chunk)
                f.write(chunk)
                sha512_hash.update(chunk)
    
    return {'url': url, 'sha512': sha512_hash.hexdigest(), 'size': total_dl_size}

def verify_gh_user_has_permissions_on_repo(gh_repo: str, gh_username: str, required_permissions: list[str], tools: MapRepoExternalTools, permissions_check_token_provider: WZGithubAppTokenProvider | None = None):
    if len(required_permissions) == 0:
        return False
    
    if permissions_check_token_provider:
        # Issue a manual API call with a token generated by the provider
        # This could be necessary for checking the permissions on a *different* repo than the one running this code (and that provided GITHUB_TOKEN)
        map_repo_split = gh_repo.split('/', 1)
        gh_access_token_secret = permissions_check_token_provider.get_access_token(map_repo_split[0], map_repo_split[1], tools)
        
        session = requests.Session()
        session.headers.update({'Accept': 'application/vnd.github+json'})
        session.headers.update({'Authorization': 'Bearer ' + gh_access_token_secret})
        session.headers.update({'X-GitHub-Api-Version': GH_REST_API_VERSION})
    
        gh_permissions_query_response = session.get('https://api.github.com/repos/{0}/collaborators/{1}/permission'.format(gh_repo, gh_username), allow_redirects=True)
        if not gh_permissions_query_response.status_code != requests.codes.ok:
            print('Failed to query permissions with status: {0}'.format(gh_permissions_query_response.status_code), file=sys.stderr)
            return False
        result = gh_permissions_query_response.json()
        session.close()
        gh_access_token_secret = None
    
    else:
        # Otherwise just default to using gh CLI to issue the API call
        # NOTE: To succeed, gh must be authenticated with an appropriate token
        # For checking the *current* repo, a GITHUB_TOKEN with contents:read (and metadata:read which is always enabled) is all that's required
        gh_get_permissions_result = subprocess.run([tools.gh_cli_exe, 'api', '-H', 'Accept: application/vnd.github+json', '-H', 'X-GitHub-Api-Version: {0}'.format(GH_REST_API_VERSION), '/repos/{0}/collaborators/{1}/permission'.format(gh_repo, gh_username)], stdout=subprocess.PIPE)
        if not gh_get_permissions_result.returncode == 0:
            return False
        result = json.loads(gh_get_permissions_result.stdout)
    
    permissions_hash = result['user']['permissions']
    
    if not gh_username == result['user']['login']:
        raise ValueError('Unexpected: Input username ({0}) does not match value in user/login object ({1})'.format(gh_username, result['user']['login']))
    
    # Check the result['user']['permissions'] dictionary for each required_permissions
    for permission in required_permissions:
        if not permission in permissions_hash:
            return False
        if not permissions_hash[permission]:
            return False
    
    return True

def verify_gh_user_match(gh_user_obj: dict, allowed_gh_users: list[dict]):
    if len(allowed_gh_users) == 0:
        return False
    
    for allowed_user in allowed_gh_users:
        if len(allowed_user) == 0:
            return False
        matched_all_values = True
        for k, v in allowed_user.items():
            if not k in gh_user_obj:
                matched_all_values = False
                break
            if gh_user_obj[k] != v:
                matched_all_values = False
                break
        
        if matched_all_values:
            return True
    
    return False

# alternative that uses look-behind to try to avoid matching anything but the body text, for use in replacement function
REGEX_FIND_UPLOAD_MAP_SECTION = r'(?sm)(?<=### Upload Map[\r\n])(.*?)(?=[\r\n]*^### |[\r\n]*\Z)'

def parse_md_url_from_text(gh_markdown_text: str):
    name_regex = "[^]]+"
    url_regex = "http[s]?://[^)]+"
    markup_regex = '\[({0})]\(\s*({1})\s*\)'.format(name_regex, url_regex)
    found_urls = [match[1] for match in re.findall(markup_regex, gh_markdown_text)]
    return found_urls

def parse_gh_map_submission_issue(gh_issue_obj: dict) -> WZGitHubMapSubmissionDetails:
    # Initial submission comments follow a template generated by .github/ISSUE_TEMPLATE/submit_map.yml
    
    gh_issue_body = gh_issue_obj['body']
    
    # Need to parse out:
    # - URL for attachment - make sure there is only one!
    # Search for "### Upload Map" section
    match = re.search(REGEX_FIND_UPLOAD_MAP_SECTION, gh_issue_body)
    if match:
        body_upload_map_contents = match.group(1)
        # Parse for markdown attachment URL
        found_urls = parse_md_url_from_text(body_upload_map_contents)
        if len(found_urls) != 1:
            raise ValueError('Expecting one map .zip attachment - {0} found'.format(len(found_urls)))
    
    # - Description body (for placing in README.md)
    pattern=r'(?sm)^### Map Description(?: \(optional\))?[\r\n]+(^```text)?[\r\n]+(.*?)[\r\n]*^(```)?[\r\n]*(?=^### |\Z)'
    match = re.search(pattern, gh_issue_body)
    if match:
        if match.group(1) and match.group(3):
            description_body = match.group(2)
        else:
            # Missing ```text / ``` surrounding markers
            # This likely means the submitter left this field blank
            # So ignore the matched text, which is likely something like "No response" (but may be subject to change by GH)
            description_body = None
    else:
        description_body = None
    
    return WZGitHubMapSubmissionDetails(gh_issue_obj['number'], found_urls[0], description_body)
    
def edit_gh_map_submission_issue_body(gh_issue_body: str, replacement_map_attachment_url: str | None = None, replacement_description: str | None = None) -> str:
    
    if replacement_map_attachment_url:
        
        map_name = get_dl_filename_from_url(replacement_map_attachment_url)
        if map_name:
            match = re.search(REGEX_FIND_UPLOAD_MAP_SECTION, gh_issue_body)
            if match:
                body_upload_map_contents = match.group(1)
                # Determine how many newlines before the attachment url in this extracted section, so we can reproduce them
                starting_newlines_match = re.search(r'^([\r\n]*)', body_upload_map_contents)
                starting_newlines = ''
                if starting_newlines_match:
                    starting_newlines = starting_newlines_match.group(1)
            
                #replacement_upload_map_section_contents = '### Upload Map\n\n[{0}]({1})\r\n\n\n'.format(map_name, replacement_map_attachment_url)
                replacement_upload_map_section_contents = '{0}[{1}]({2})'.format(starting_newlines, map_name, replacement_map_attachment_url)
                gh_issue_body = re.sub(REGEX_FIND_UPLOAD_MAP_SECTION, replacement_upload_map_section_contents, gh_issue_body)
            else:
                print('Failed to find existing Upload Map section in Issue body', file=sys.stderr)
        else:
            print('Failed to get filename from new attachment url: {0}'.format(replacement_map_attachment_url), file=sys.stderr)
    
    return gh_issue_body
    

class GHMapSubmissionFollowupCommandPermissionError(ValueError): pass

def parse_gh_map_submission_followup_comment_commands(gh_repo: str, gh_issue_obj: dict, gh_comment_obj: dict, map_submission_details: WZGitHubMapSubmissionDetails, tools: MapRepoExternalTools) -> dict | None:
    # Template for how someone attaches a "fixed" map to an issue:
    #
    # /replace map-upload
    #
    # <attachment dragged into issue comment>
    #
    
    match = re.search(r'(?sm)^/replace[ \t]+(\S*)[\s\r\n]*(.*?)(?=^[\r\n]*/replace |[\r\n]*\Z)', gh_comment_obj['body'])
    if not match:
        raise ValueError('Expecting valid /replace command - failed')
    
    replaced_properties = {}
    
    replace_command_verb = match.group(1)
    replace_command_contents = match.group(2)
    
    if replace_command_verb == 'validation':
        # Special permission check for `/replace validation` command:
        # - *ONLY* accept from user with at least triage permissions on this repo
        if not verify_gh_user_has_permissions_on_repo(gh_repo, gh_comment_obj['user']['login'], ['triage'], tools):
            raise GHMapSubmissionFollowupCommandPermissionError('ERROR: User does not have necessary permissions for this action')
        
        # Return 'None' which will skip any "replacement" logic in the caller but still trigger a re-run of the validation
        return None
    
    # Verify the comment is either from:
    # - The original issue author *or*
    # - A user with at least triage permissions on this repo
    expectedOriginalIssueAuthorUser = [{
        'login': gh_issue_obj['user']['login'],
        'id': gh_issue_obj['user']['id'],
        'node_id': gh_issue_obj['user']['node_id']
    }]
    if not verify_gh_user_match(gh_comment_obj['user'], expectedOriginalIssueAuthorUser) and not verify_gh_user_has_permissions_on_repo(gh_repo, gh_comment_obj['user']['login'], ['triage'], tools):
        raise GHMapSubmissionFollowupCommandPermissionError('ERROR: User does not have necessary permissions for this action')
    
    if replace_command_verb == 'map-upload':
        # Parse contents for markdown attachment URL
        found_urls = parse_md_url_from_text(replace_command_contents)
        if len(found_urls) != 1:
            raise ValueError('Expecting one map .zip attachment - {0} found'.format(len(found_urls)))
        
        map_submission_details.update_map_attachment_from_followup_comment(gh_comment_obj['id'], found_urls[0])
        replaced_properties['map'] = True
    else:
        raise ValueError('Unexpected / unknown replace command ({0})'.format(replace_command_verb))
    
    return replaced_properties

def build_map_submission_analysis_response(map_archive_path: Path, map_dl_details: dict, map_submission_details: WZGitHubMapSubmissionDetails, gh_repo: str, gh_run_id: str, validation_details: MapValidationDetails) -> [str]:
    
    result_lines = ['<!-- Map Validation -->', '']
    
    if validation_details.passed_validation():
        emoji_status_symbol = '\U00002705'
    else:
        emoji_status_symbol = '\N{cross mark}'
    
    map_dl_file_name = get_dl_filename_from_url(map_dl_details['url'])
    
    try:
        result_lines.append('## {0} Map: {1}'.format(emoji_status_symbol, validation_details.map_info_json['name']))
    except KeyError:
        result_lines.append('## {0} Map: (missing `name` property)'.format(emoji_status_symbol))
        pass
    if validation_details.passed_validation():
        try:
            result_lines.append('by: {0}'.format(validation_details.map_info_json['author']['name']))
        except KeyError:
            result_lines.append('- by: Anonymous (missing `author` property)')
            pass
    result_lines.append('')
    result_lines.append('')
    result_lines.append('- üì¶ [Map Package (`{0}`)]({1})'.format(map_dl_file_name, map_dl_details['url']))
    if gh_run_id:
        result_lines.append('- üñº [Get Map Preview](https://github.com/{0}/actions/runs/{1})'.format(gh_repo, gh_run_id))
    result_lines.append('')
    result_lines.append('### Status: {0}'.format(', '.join([f'`{status}`' for status in validation_details.get_status_list()])))
    if validation_details.passed_validation() and len(validation_details.info_validation_result.errors_non_fatal) > 0:
        result_lines.append('> \u26A0\uFE0F Non-Fatal Errors detected - please resolve if possible!')
    result_lines.append('')
    
    if len(validation_details.info_validation_result.errors) > 0:
        result_lines.append('### Errors:')
        result_lines.append('```')
        for error in validation_details.info_validation_result.errors:
            result_lines.append(f'\N{cross mark} {error}')
        result_lines.append('```')
        result_lines.append('')
    
    if len(validation_details.info_validation_result.errors_non_fatal) > 0:
        result_lines.append('### Non-Fatal Errors:')
        result_lines.append('```')
        for error in validation_details.info_validation_result.errors_non_fatal:
            result_lines.append(f'\u26A0\uFE0F {error}')
        result_lines.append('```')
        result_lines.append('')

    if len(validation_details.info_validation_result.warnings) > 0:
        result_lines.append('### Warnings:')
        result_lines.append('```')
        for warning in validation_details.info_validation_result.warnings:
            result_lines.append(warning)
        result_lines.append('```')
        result_lines.append('')
    
    recommendation_lines = []
    if len(validation_details.info_validation_result.errors) > 0:
        recommendation_lines.append('- Resolve validation errors listed above')
    if len(validation_details.info_validation_result.errors_non_fatal) > 0:
        recommendation_lines.append('- Resolve non-fatal validation errors listed above, if at all possible')
    if validation_details.needs_format_conversion():
        recommendation_lines.append('- Review the validation warnings for potential issues converting the map to the latest format (`Conversion Warning` / `Conversion Error`)')
        recommendation_lines.append('  - **Important:** Uploading this map will automatically convert it to the latest map format.')
        if gh_run_id:
            recommendation_lines.append('  - For convenience, a copy of the map that has been converted to the latest map format is available [here](https://github.com/{0}/actions/runs/{1}) as an artifact named `map-converted`.'.format(gh_repo, gh_run_id))
    if validation_details.name_conflict:
        recommendation_lines.append('- Rename the map (conflicts with a map that already has the name `{0}`)'.format(validation_details.map_info_json['name']))
        recommendation_lines.append('  - If this is a new version, you can append a version (ex. `{0}-v2`)'.format(validation_details.map_info_json['name']))
        recommendation_lines.append('  - If this is a map made (or modified) by a different creator, you can prepend/append the additional author\'s name: (ex. `Author-{0}`)'.format(validation_details.map_info_json['name']))
    if validation_details.mapdir_folder_name_mismatch:
        recommendation_lines.append('- Ensure the map folder matches the map name')
        recommendation_lines.append('  - i.e. A map named "{0}" should be in the repo at a path of "maps/{0}"'.format(validation_details.map_info_json['name']))
    
    if len(recommendation_lines) > 0:
        result_lines.append('### Recommendations:')
        for line in recommendation_lines:
            result_lines.append(line)
        result_lines.append('')
    
    if not validation_details.passed_validation():
        result_lines.append('## How to Upload a Fixed Map:')
        result_lines.append('1. Follow the recommendations above.')
        result_lines.append('2. Ensure your new fixed map ends in `.zip`')
        result_lines.append('3. At the bottom of this page, copy the following into the Write / new comment field:')
        result_lines.append('```')
        result_lines.append('/replace map-upload')
        result_lines.append('')
        result_lines.append('```')
        result_lines.append('4. Then attach the new map package `.zip` to the new comment.')
        result_lines.append('5. Finally, press the "Comment" button to add the new comment.')
        result_lines.append('')
    
    result_lines.append('---')
    result_lines.append('')
    
    result_lines.append('<details>')
    result_lines.append('')
    result_lines.append('<summary>Map Info JSON:</summary>')
    result_lines.append('')
    result_lines.append('<!-- Begin: MapInfoJSON -->')
    result_lines.append('```json')
    result_lines.append(json.dumps(validation_details.map_info_json, ensure_ascii=False, indent=2))
    result_lines.append('```')
    result_lines.append('<!-- End: MapInfoJSON -->')
    result_lines.append('')
    result_lines.append('</details>')
    result_lines.append('')
    
    with zipfile.ZipFile(map_archive_path, 'r') as mapzip:
        map_zip_contents = mapzip.namelist()
    
    if map_zip_contents:
        result_lines.append('<details>')
        result_lines.append('')
        result_lines.append('<summary>Map Package Contents:</summary>')
        result_lines.append('')
        result_lines.append('```')
        num_zip_lines_printed = 0
        for map_zip_entry in map_zip_contents:
            result_lines.append('- ' + ((map_zip_entry[:80] + '...') if len(map_zip_entry) > 83 else map_zip_entry))
            num_zip_lines_printed += 1
            if num_zip_lines_printed >= 100:
                result_lines.append('... truncated ... ({0} total items!)'.format(len(map_zip_contents)))
                break
        result_lines.append('```')
        result_lines.append('')
        result_lines.append('</details>')
        result_lines.append('')
    
    description_details_json = {}
    if map_submission_details.description_body:
        encoded_description = map_submission_details.description_body.encode('utf-8')
        description_size = len(encoded_description)
        description_sha512 = hashlib.sha512(encoded_description)
        description_details_json = {
          'sha512': description_sha512.hexdigest(),
          'size': description_size
        }
    
    analysis_details_json = {
        'map': {
          'url': map_dl_details['url'],
          'sha512': map_dl_details['sha512'],
          'size': map_dl_details['size']
        },
        'description': description_details_json,
        'status': ('pass' if validation_details.passed_validation() else 'fail')
    }
    
    result_lines.append('<details>')
    result_lines.append('')
    result_lines.append('<summary>Analysis Details:</summary>')
    result_lines.append('')
    result_lines.append('<!-- Begin: AnalysisDetails -->')
    result_lines.append('```json')
    result_lines.append(json.dumps(analysis_details_json, ensure_ascii=False, indent=2))
    result_lines.append('```')
    result_lines.append('<!-- End: AnalysisDetails -->')
    result_lines.append('')
    result_lines.append('</details>')
    result_lines.append('')
    
    if validation_details.passed_validation():
        result_lines.append('## Moderator Instructions:')
        result_lines.append('')
        result_lines.append('<details>')
        result_lines.append('')
        result_lines.append('<summary>How to Approve This Map Upload:</summary>')
        result_lines.append('')
        result_lines.append('> You **must** have triage privileges on this repo to approve a map upload.')
        result_lines.append('1. Copy the following into a new comment:')
        result_lines.append('```')
        result_lines.append('/approve')
        result_lines.append('```')
        result_lines.append('2. Submit the comment.')
        result_lines.append('')
        result_lines.append('</details>')
    
    return result_lines

class MapSubmissionContentProcessingResult(IntEnum):
    SUCCESS = 0
    FAILURE = 1
    FAILURE_MAP_DOWNLOAD = 2
    FAILURE_PERMISSIONS = 5
    FAILURE_ADD_COMMENT = 6
    FAILURE_EDIT_ISSUE_BODY = 7

def validate_gh_map_submission_comment(map_repos_config_json_path: str, output_temp_folder: Path, gh_repo: str, gh_run_id: str, gh_issue_obj: dict, gh_comment_obj: dict | None = None, gen_assets_folder: Path | None = None, dry_run: bool = False, tools: MapRepoExternalTools = MapRepoExternalTools()) -> MapSubmissionContentProcessingResult:
    try:
        # Parse out the attachment URL and description from the original issue
        map_submission_details = parse_gh_map_submission_issue(gh_issue_obj)
    except ValueError as e:
        # Someone probably didn't upload required information, like a map .zip
        print('ERROR: Failed to process issue body with error: {0}'.format(str(e)), file=sys.stderr)
        return MapSubmissionContentProcessingResult.FAILURE
    
    # Parse the new comment object, if present (might replace the map with a new upload)
    comment_replaced_items = None
    if gh_comment_obj:
        # Parse and replace values (ex. attachment url) + process commmands, based on the follow-up comment
        try:
            comment_replaced_items = parse_gh_map_submission_followup_comment_commands(gh_repo, gh_issue_obj, gh_comment_obj, map_submission_details, tools)
        except GHMapSubmissionFollowupCommandPermissionError:
            print('ERROR: User does not have necessary permissions for this action', file=sys.stderr)
            return MapSubmissionContentProcessingResult.FAILURE_PERMISSIONS
        except ValueError as e:
            print('ERROR: Failed to process follow-up comment with error: {0}'.format(str(e)), file=sys.stderr)
            return MapSubmissionContentProcessingResult.FAILURE
    
    # Download the attachment file (map package)
    temp_dl_map_dir = output_temp_folder.joinpath('dl')
    os.makedirs(str(temp_dl_map_dir), exist_ok=True)
    temp_archive_dl_path = temp_dl_map_dir.joinpath('dl-map.wz')
    try:
        map_dl_details = dl_gh_attachment(map_submission_details.map_attachment_url, gh_repo, temp_archive_dl_path)
    except requests.exceptions.HTTPError as e:
        # Failed to download the map file attachment - url might be wrong, or might not exist
        print('Failed to download attachment ({0}): {1}'.format(map_submission_details.map_attachment_url, e.response.status_code), file=sys.stderr)
        return MapSubmissionContentProcessingResult.FAILURE_MAP_DOWNLOAD
    except ValueError as e:
        print('Failed to download attachment ({0}) with error: {1}'.format(map_submission_details.map_attachment_url, str(e)), file=sys.stderr)
        return MapSubmissionContentProcessingResult.FAILURE_MAP_DOWNLOAD
    
    # Validate the map
    repos_config = MapReposConfig(map_repos_config_json_path)
    uniqueness_checker = MapNameUniquenessCheck(output_temp_folder.joinpath('tmp-repos-check'))
    try:
        validation_details = validate_map(temp_archive_dl_path, True, repos_config, tools, uniqueness_checker, enforce_format_checks=False)
    except FailedToProcessMapError as e:
        print('ERROR: Failed to process map attachment - invalid map package?', file=sys.stderr)
        return MapSubmissionContentProcessingResult.FAILURE
    
    # Generate various output assets (if requested), like a map preview
    if gen_assets_folder:
        os.makedirs(str(gen_assets_folder), exist_ok=True)
        
        # Generate map preview
        generate_map_preview_png(temp_archive_dl_path, gen_assets_folder.joinpath('map-preview.png'), tools)
        
        # Generate a converted map package, if the map passed validation but needs conversion (for manual testing, if desired)
        if validation_details.passed_validation() and validation_details.needs_format_conversion():
            converted_map_output_path = gen_assets_folder.joinpath('{0}-converted.wz'.format(validation_details.map_info_json['name']))
            maptools_convert_result = subprocess.run([tools.maptools_exe, 'package', 'convert', '--levelformat=latest', '--format=latest', temp_archive_dl_path, str(converted_map_output_path)])
            if maptools_convert_result.returncode != 0:
                print('WARNING: Failed to convert map: {0}'.format(validation_details.map_info_json['name']), file=sys.stderr)
                # But continue outputting results anyway
    
    # Build the output comment
    output_lines = build_map_submission_analysis_response(temp_archive_dl_path, map_dl_details, map_submission_details, gh_repo, gh_run_id, validation_details)
    
    # Write body output to temp file
    temp_comment_body_dir = output_temp_folder.joinpath('comment')
    os.makedirs(str(temp_comment_body_dir), exist_ok=True)
    temp_comment_body_file_path = temp_comment_body_dir.joinpath('validation-results.md')
    with open(temp_comment_body_file_path, mode='wb') as f:
        f.write('\n'.join(output_lines).encode('utf-8'))
    
    # Output validation comment body to stdout
    for line in output_lines:
        print(line)
    
    # Update the issue labels based on validation passed status
    if validation_details.passed_validation():
        desired_label = 'needs approval'
        remove_labels = 'failed validation,unprocessed'
    else:
        desired_label = 'failed validation'
        remove_labels = 'needs approval,unprocessed'
    
    gh_issue_adjust_labels_result = subprocess_run_modification_cmd_wrapper(dry_run, [tools.gh_cli_exe, 'issue', 'edit', gh_issue_obj['html_url'], '--add-label', desired_label, '--remove-label', remove_labels], stdout=subprocess.PIPE)
    # we don't really care if the above fails, it's just the labels
    
    # If the comment replaced things, update them in the original issue body
    if comment_replaced_items:
        
        new_body = gh_issue_obj['body']
        
        if 'map' in comment_replaced_items and comment_replaced_items['map']:
            # Update the map download link in the original issue body
            new_body = edit_gh_map_submission_issue_body(new_body, map_submission_details.map_attachment_url)
        
        if new_body != gh_issue_obj['body']:
            # Write out the new issue body to a temp file
            temp_issue_body_file_path = temp_comment_body_dir.joinpath('issue-updated-body.md')
            with open(temp_issue_body_file_path, mode='wb') as f:
                f.write(new_body.encode('utf-8'))
            
            # Edit body in issue original post
            gh_issue_edit_body_result = subprocess_run_modification_cmd_wrapper(dry_run, [tools.gh_cli_exe, 'issue', 'edit', gh_issue_obj['html_url'], '--body-file', temp_issue_body_file_path], stdout=subprocess.PIPE)
            if not gh_issue_edit_body_result.returncode == 0:
                print('Failed to update body in issue {0} original post, but succeeded posting validation update'.format(gh_issue_obj['number']), file=sys.stderr)
                return MapSubmissionContentProcessingResult.FAILURE_EDIT_ISSUE_BODY
    
    # Add the validation results output as a new comment to the issue
    gh_create_comment_result = subprocess_run_modification_cmd_wrapper(dry_run, [tools.gh_cli_exe, 'issue', 'comment', gh_issue_obj['html_url'], '--body-file', str(temp_comment_body_file_path)], stdout=subprocess.PIPE)
    if not gh_create_comment_result.returncode == 0:
        print('Failed to add new issue comment with validation results', file=sys.stderr)
        return MapSubmissionContentProcessingResult.FAILURE_ADD_COMMENT
    
    return MapSubmissionContentProcessingResult.SUCCESS

class WZMapSubmissionValidationCommentDetails:
    def __init__(self, bot_validation_comment_obj: dict, gh_issue_obj: dict | None):
        validation_comment_id = bot_validation_comment_obj['id']
        
        # Verify that the comment author is expected (bot)
        if not verify_gh_user_match(bot_validation_comment_obj['user'], WZ_EXPECTED_VALIDATION_COMMENT_AUTHORS):
            raise ValueError('ERROR: Specified comment ({0}) was not authored by the expected bot account'.format(validation_comment_id))
        
        # Verify that the comment has not been edited since it was created (updated_at must match created_at)
        if bot_validation_comment_obj['created_at'] != bot_validation_comment_obj['updated_at']:
            raise ValueError('ERROR: Specified comment ({0}) has been modified'.format(validation_comment_id))
    
        # Extract Analysis Details:
        # <!-- Begin: AnalysisDetails -->
        # ```json
        # {
        #   # ... various information provided by build_map_submission_analysis_response ...
        # }
        # ```
        # <!-- End: AnalysisDetails -->
        REGEX_FIND_ANALYSIS_DETAILS_JSON = r'(?sm)^<!-- Begin: AnalysisDetails -->[\s]+^```json[\s]*?^(.*?)[\s]+^```[\s]*?(?=^<!-- End: AnalysisDetails -->)'
        match = re.search(REGEX_FIND_ANALYSIS_DETAILS_JSON, bot_validation_comment_obj['body'])
        if not match:
            raise ValueError('ERROR: Unable to find AnalysisDetails json')
    
        analysis_details_json = json.loads(match.group(1))
        self.map = analysis_details_json['map']
        self.description = analysis_details_json['description']
        self.status = analysis_details_json['status']
        
        # Extract Map Info JSON:
        # <!-- Begin: MapInfoJSON -->
        # ```json
        # {
        #   # ... the map info json contents ...
        # }
        # ```
        # <!-- End: MapInfoJSON -->
        REGEX_FIND_MAP_INFO_JSON = r'(?sm)^<!-- Begin: MapInfoJSON -->[\s]+^```json[\s]*?^(.*?)[\s]+^```[\s]*?(?=^<!-- End: MapInfoJSON -->)'
        match = re.search(REGEX_FIND_MAP_INFO_JSON, bot_validation_comment_obj['body'])
        if not match:
            raise ValueError('ERROR: Unable to find MapInfoJSON')
        
        self.map_info = json.loads(match.group(1))
        
        # Get the description body from the issue's opening post
        if gh_issue_obj:
            try:
                map_submission_details = parse_gh_map_submission_issue(gh_issue_obj)
                self.description['body'] = map_submission_details.description_body
            except ValueError:
                pass
        
    def get_description_body(self) -> str | None:
        if not 'body' in self.description:
            return None
        return self.description['body']
        
    def description_body_matches_expected(self) -> bool:
        body_text = self.get_description_body()
        if body_text is None:
            if ((not 'size' in self.description) or (self.description['size'] == 0)):
                # expecting no description
                return True
            else:
                return False
        encoded_text = body_text.encode('utf-8')
        if len(encoded_text) != self.description['size']:
            return False
        sha512_hash = hashlib.sha512(encoded_text)
        return self.description['sha512'] == sha512_hash.hexdigest()

def fixup_gh_paginate_results(gh_paginate_results: str) -> str:
    # The gh CLI may just append the page results textually (i.e. if the API returns an array for each page, gh may just concantenate the full responses, yielding invalid JSON)
    # Correct this to make a single top-level array with all the contents
    
    # Look for a line that starts with ]
    # Followed by another line that starts with [
    fixup_pattern = r'(?m)^\][\r\n]+\['
    gh_paginate_results = re.sub(fixup_pattern, '', gh_paginate_results)
    return gh_paginate_results

def find_approved_gh_issue_validation_comment(gh_repo: str, gh_issue_obj: dict, gh_comment_obj: dict, tools: MapRepoExternalTools = MapRepoExternalTools()) -> dict:
    # FIND THE APPROVED COMMENT
    # - This should be the most recent comment posted by the bot that starts with <!-- Map Validation -->, _prior_ to gh_comment_obj
    
    current_issue_number = gh_issue_obj['number']
    current_comment_id = gh_comment_obj['id']
    
    # gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /repos/OWNER/REPO/issues/ISSUE_NUMBER/comments --paginate
    gh_get_all_issue_comments_result = subprocess.run([tools.gh_cli_exe, 'api', '-H', 'Accept: application/vnd.github+json', '-H', 'X-GitHub-Api-Version: {0}'.format(GH_REST_API_VERSION), '/repos/{0}/issues/{1}/comments'.format(gh_repo, current_issue_number), '--paginate'], stdout=subprocess.PIPE)
    if not gh_get_all_issue_comments_result.returncode == 0:
        message = ''
        try:
            gh_failure_obj = json.loads(gh_get_all_issue_comments_result.stdout)
            if 'message' in gh_failure_obj:
                message = gh_failure_obj['message']
        except ValueError:
            pass
        except json.decoder.JSONDecodeError:
            pass
        raise ValueError('ERROR: Failed to fetch issue ({0}) comments, with error: {1}'.format(current_issue_number, message))
    
    # fixup gh cli paginated results
    all_comments_results = fixup_gh_paginate_results(gh_get_all_issue_comments_result.stdout.decode('utf-8'))
    issue_comments = json.loads(all_comments_results)
    
    # sort comments by created_at (most recent first)
    issue_comments = sorted(issue_comments, key=lambda x: datetime.strptime(x['created_at'],"%Y-%m-%dT%H:%M:%SZ"), reverse=True) # ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ)
    
    # find the startPos for the search (the gh_comment_obj's comment's index)
    curr_comment_index = None
    for i, comment in enumerate(issue_comments):
        if comment['id'] == current_comment_id:
            curr_comment_index = i
            break
    if curr_comment_index is None:
        raise ValueError('ERROR: Failed to find current comment (id: {0}) in issue ({1}) comments'.format(current_comment_id, current_issue_number))
    
    # search from gh_comment_obj to find the most recent comment posted by the bot that starts with <!-- Map Validation -->
    for i, comment in enumerate(issue_comments, curr_comment_index):
        if comment['body'].startswith('<!-- Map Validation -->'):
            # Found likely map validation comment
            # Verify it was posted by an expected author (bot)
            if not verify_gh_user_match(comment['user'], WZ_EXPECTED_VALIDATION_COMMENT_AUTHORS):
                print('Found a seeming Map Validation comment (id: {0}), but it was not posted by an expected author (bot) - ignoring'.format(comment['id']), file=sys.stderr)
                continue
            # Return the found comment
            return comment
    
    # did not find a match
    raise ValueError('ERROR: Failed to find validation results in issue ({0}) comments'.format(current_issue_number))

class MapSubmissionApprovalResult(IntEnum):
    SUCCESS = 0
    FAILURE = 1
    FAILURE_MAP_STATUS = 2
    FAILURE_DESCRIPTION_CHANGED = 3
    FAILURE_MAP_CONVERSION = 4
    FAILURE_PERMISSIONS = 5

def handle_gh_map_submission_approval(map_repos_config_json_path: str, output_temp_folder: Path, gh_repo: str, gh_run_id: str, gh_issue_obj: dict, gh_comment_obj: dict, dry_run: bool = False, map_repo_management_token_provider: WZGithubAppTokenProvider | None = None, tools: MapRepoExternalTools = MapRepoExternalTools()) -> MapSubmissionApprovalResult:
    # IMPORTANT: Verify that the author of the ‚Äú/approve <issue_number>/<comment_id>‚Äù comment has triage (or higher) priviliges for this repo
    if not verify_gh_user_has_permissions_on_repo(gh_repo, gh_comment_obj['user']['login'], ['triage'], tools):
        print('ERROR: User does not have necessary permissions for this action', file=sys.stderr)
        return MapSubmissionApprovalResult.FAILURE_PERMISSIONS
    
    repos_config = MapReposConfig(map_repos_config_json_path)
    current_issue_number = gh_issue_obj['number']
    
    # gh_comment_obj['body'] should take the form of "/approve" (could support options/flags in the future - for now, we don't)
    approve_comment_pattern = r'^/approve[\t\v ]*([\S]*)?'
    match = re.search(approve_comment_pattern, gh_comment_obj['body'])
    if not match:
        print('ERROR: Invalid /approve command', file=sys.stderr)
        return MapSubmissionApprovalResult.FAILURE
    
    # Find & fetch the approved comment
    try:
        approved_comment_obj = find_approved_gh_issue_validation_comment(gh_repo, gh_issue_obj, gh_comment_obj, tools)
    except ValueError as e:
        print('ERROR: Failed to fetch approved validation with: {1}'.format(str(e)), file=sys.stderr)
        return MapSubmissionApprovalResult.FAILURE
    approved_comment_id = approved_comment_obj['id']
    
    # Extract bot comment details (with some basic validation)
    try:
        approved_map_info = WZMapSubmissionValidationCommentDetails(approved_comment_obj, gh_issue_obj)
    except ValueError as e:
        print('ERROR: Failed to extract analysis from comment ({0}) with: {1}'.format(approved_comment_id, str(e)), file=sys.stderr)
        return MapSubmissionApprovalResult.FAILURE
    
    # Verify that the comment‚Äôs calculated Status was Pass
    if approved_map_info.status != 'pass':
        print('ERROR: Map status ({0}) is not \'pass\''.format(approved_map_info.status), file=sys.stderr)
        return MapSubmissionApprovalResult.FAILURE_MAP_STATUS
        
    # Check that the description is unchanged since the lastest validation / analysis
    if not approved_map_info.description_body_matches_expected():
        # The description has been modified since the latest validation / analysis
        # Moderator will need to issue command again to re-run validation before this can be approved
        print('Failure: Description has been changed since the last automated analysis. Please verify the description and then re-run validation with: /replace validation', file=sys.stderr)
       
        # Output a comment to the issue to this effect
        temp_comment_body_dir = output_temp_folder.joinpath('comment')
        os.makedirs(str(temp_comment_body_dir), exist_ok=True)
        temp_failure_comment_body_file_path = temp_comment_body_dir.joinpath('approval-failure.md')
        with open(temp_failure_comment_body_file_path, mode='w', encoding='utf-8') as f:
            f.write('### Moderator Notice:\n\n')
            f.write('**Approval Failure:**\n- Description has been changed since the last automated analysis.\n\nPlease verify the description and then re-run validation with:\n\n```\n/replace validation\n```\n\n')
        
        gh_issue_add_failure_comment_result = subprocess_run_modification_cmd_wrapper(dry_run, [tools.gh_cli_exe, 'issue', 'comment', gh_issue_obj['html_url'], '--body-file', str(temp_failure_comment_body_file_path)], stdout=subprocess.PIPE)
        if not gh_issue_add_failure_comment_result.returncode == 0:
            print('Failed to add new comment to issue {0}'.format(gh_issue_obj['number']), file=sys.stderr)
        
        return MapSubmissionApprovalResult.FAILURE_DESCRIPTION_CHANGED
    
    # Download the map archive referenced in that comment
    temp_dl_map_dir = output_temp_folder.joinpath('dl')
    os.makedirs(str(temp_dl_map_dir), exist_ok=True)
    temp_dl_map_archive = temp_dl_map_dir.joinpath('dl-map.wz')
    dl_attachment_result = dl_gh_attachment(approved_map_info.map['url'], gh_repo, temp_dl_map_archive)
    
    # Verify that it matches the expected size and hash
    if dl_attachment_result['size'] != approved_map_info.map['size']:
        print('Downloaded map size ({0}) does not match expected size ({1})'.format(dl_attachment_result['size'], approved_map_info.map['size']), file=sys.stderr)
        return MapSubmissionApprovalResult.FAILURE
    if dl_attachment_result['sha512'] != approved_map_info.map['sha512']:
        print('Downloaded map sha512 ({0}) does not match expected value ({1})'.format(dl_attachment_result['sha512'], approved_map_info.map['sha512']), file=sys.stderr)
        return MapSubmissionApprovalResult.FAILURE
    
    # Use maptools to convert the map to the latest format as a map folder (NOTE: could use --preserve-mods in the future once we support flat map stats / texture / etc modifications?)
    temp_converted_map_folder = output_temp_folder.joinpath('converted', approved_map_info.map_info['name'])
    if temp_converted_map_folder.is_dir():
        # Directory already exists - delete it or maptools command will fail
        shutil.rmtree(temp_converted_map_folder, ignore_errors=True)
    maptools_convert_result = subprocess.run([tools.maptools_exe, 'package', 'convert', '--levelformat=latest', '--format=latest', '--output-uncompressed', temp_dl_map_archive, temp_converted_map_folder])
    if maptools_convert_result.returncode != 0:
        print('Failed to unpack / convert map', file=sys.stderr)
        return MapSubmissionApprovalResult.FAILURE_MAP_CONVERSION
    
    # Double-check: Validate the converted map
    uniqueness_checker = MapNameUniquenessCheck(output_temp_folder.joinpath('tmp-repos-check'))
    validation_details = validate_map(temp_converted_map_folder, True, repos_config, tools, uniqueness_checker, enforce_format_checks=True)
    if not validation_details.passed_validation():
        print('Converted map failed to pass validation with status: {0}'.format(validation_details.get_status_list()), file=sys.stderr)
        return MapSubmissionApprovalResult.FAILURE
    
    # Write out the description (if present) as README.md
    description_body = approved_map_info.get_description_body()
    if description_body and re.match(r'[\S]+', description_body): # If description is present and is not just whitespace
        # Convert any CRLF line endings to LF
        description_body_binary = description_body.encode('utf-8')
        description_body_binary = description_body_binary.replace(b'\r\n', b'\n')
        description_body_binary = description_body_binary.replace(b'\r', b'\n')
        # Write out description to README.md in map folder
        description_readme_filepath = temp_converted_map_folder.joinpath('README.md')
        with open(description_readme_filepath, mode='wb') as f:
            f.write(description_body_binary)
    
    # Determine the appropriate map repo to add the map to (based on players count for the map)
    submission_repo = repos_config.get_repo_for_new_map_submissions(validation_details.map_info_json['players'])
    
    # Clone that map repo
    maprepo_local_path = output_temp_folder.joinpath('map-repo', submission_repo)
    github_map_repo_full_clone_url = 'https://github.com/{0}.git'.format(submission_repo)
    git_clone_map_repo_result = subprocess.run([tools.git_exe, 'clone', '--', github_map_repo_full_clone_url, str(maprepo_local_path)], stdout=subprocess.PIPE)
    if git_clone_map_repo_result.returncode != 0:
        print('Failed to clone {0}, with error:\n{1}'.format(github_map_repo_full_clone_url, git_clone_map_repo_result.stdout), file=sys.stderr)
        return MapSubmissionApprovalResult.FAILURE
    
    desired_maprepo_map_output_path = maprepo_local_path.joinpath('maps', validation_details.map_info_json['name'])
    # Verify that the self-contained map folder does not conflict with any existing map folder
    if desired_maprepo_map_output_path.exists() or path_exists_case_insensitive(str(maprepo_local_path.joinpath('maps')), validation_details.map_info_json['name']):
        print('Failed to export map to map repo - maps/{0} already exists'.format(desired_maprepo_map_output_path.name), file=sys.stderr)
        return MapSubmissionApprovalResult.FAILURE
    
    # Copy the self-contained map folder to the map repo
    copy_tree(str(temp_converted_map_folder), str(desired_maprepo_map_output_path))
    
    try:
        # Prepare a new commit
        # - Set the committer
        #   (Default to the user who issued the /approve command.)
        #   (To attribute to a bot / GH app, see: https://github.com/orgs/community/discussions/24664, and set GIT_COMMITTER_NAME and GIT_COMMITTER_EMAIL env variables)
        subprocess_run_modification_cmd_wrapper(dry_run, [tools.git_exe, 'config', '--local', 'user.email', '{0}+{1}@users.noreply.github.com'.format(gh_comment_obj['user']['id'], gh_comment_obj['user']['login'])], cwd=maprepo_local_path, check=True)
        subprocess_run_modification_cmd_wrapper(dry_run, [tools.git_exe, 'config', '--local', 'user.name', gh_comment_obj['user']['login']], cwd=maprepo_local_path, check=True)
        # - Prepare a commit body, referencing the map submission issue (with a link)
        commit_title = 'Add Map: {0}'.format(validation_details.map_info_json['name'])
        commit_msg = 'Map submission: {0}'.format(gh_issue_obj['html_url'])
        
        # Stage all new files
        subprocess.run([tools.git_exe, 'add', '-A'], cwd=maprepo_local_path, check=True)
        
        # Add the new commit
        commit_author = '{0} <{1}+{0}@users.noreply.github.com>'.format(gh_issue_obj['user']['login'], gh_issue_obj['user']['id'])
        subprocess.run([tools.git_exe, 'commit', '-a', '--author={0}'.format(commit_author), '-m', commit_title, '-m', commit_msg], cwd=maprepo_local_path, check=True)
    except subprocess.CalledProcessError as e:
        print(str(e), file=sys.stderr)
        return MapSubmissionApprovalResult.FAILED
    
    # Push the new commit to the appropriate map repo‚Äôs main branch (potentially using an access token)
    map_repo_push_auth_prefix = ''
    if map_repo_management_token_provider:
        if not dry_run:
            map_repo_split = submission_repo.split('/', 1)
            map_push_access_token = map_repo_management_token_provider.get_access_token(map_repo_split[0], map_repo_split[1], tools)
            if not map_push_access_token:
                return MapSubmissionApprovalResult.FAILED
            map_repo_push_auth_prefix = 'x-access-token:{0}@'.format(map_push_access_token)
            map_push_access_token = None
        else:
            print('DRYRUN - Would request access token from token provider')
    
    if not dry_run:
        git_push_to_map_repo_result = subprocess.run([tools.git_exe, 'push', 'https://{0}github.com/{1}.git'.format(map_repo_push_auth_prefix, submission_repo), 'main:main'], cwd=maprepo_local_path)
        if git_push_to_map_repo_result.returncode != 0:
            print('Failed to push to {0}'.format(submission_repo), file=sys.stderr)
            return MapSubmissionApprovalResult.FAILED
    else:
        print('DRYRUN - Would push new commit in {0} to: https://github.com/{1}.git:main'.format(maprepo_local_path, submission_repo))
    
    # Attempt to add a comment to the submission issue (and close it)
    gh_issue_remove_triage_label = subprocess_run_modification_cmd_wrapper(dry_run, [tools.gh_cli_exe, 'issue', 'edit', gh_issue_obj['html_url'], '--add-label', 'approved', '--remove-label', 'unprocessed,needs approval'], stdout=subprocess.PIPE) # we don't care if this fails
    gh_issue_close_result = subprocess_run_modification_cmd_wrapper(dry_run, [tools.gh_cli_exe, 'issue', 'close', gh_issue_obj['html_url'], '--reason', 'completed', '--comment', 'Map processed and uploaded.\n\n(Queued for publishing with next map database rebuild.)'], stdout=subprocess.PIPE)
    if not gh_issue_close_result.returncode == 0:
        # Just ignore errors at this point - just print a debug message
        print('Failed to close issue {0}, but succeeded uploading the map'.format(current_issue_number))
    
    return MapSubmissionApprovalResult.SUCCESS


def process_map_submission_comment(map_repos_config_json_path: str, output_temp_folder: Path, gh_repo: str, gh_run_id: str, gh_issue_obj: dict, gh_comment_obj: dict | None = None, gen_assets_folder: Path | None = None, dry_run: bool = False, map_repo_management_token_provider: WZGithubAppTokenProvider | None = None) -> int:
    
    if gh_issue_obj['state'] != 'open':
        print('Issue {0} is not open - ignoring'.format(gh_issue_obj['number']), file=sys.stderr)
        return 1
    
    if gh_comment_obj:
        # Check for command comments
        if gh_comment_obj['body'].startswith("/replace "):
            return validate_gh_map_submission_comment(map_repos_config_json_path, output_temp_folder, gh_repo, gh_run_id, gh_issue_obj, gh_comment_obj, gen_assets_folder=gen_assets_folder, dry_run=dry_run)
        elif gh_comment_obj['body'].startswith("/approve"):
            return handle_gh_map_submission_approval(map_repos_config_json_path, output_temp_folder, gh_repo, gh_run_id, gh_issue_obj, gh_comment_obj, dry_run, map_repo_management_token_provider)
        else:
            # Ignore other comments
            return 0
    else:
        # Newly opened issue - process the original post
        return validate_gh_map_submission_comment(map_repos_config_json_path, output_temp_folder, gh_repo, gh_run_id, gh_issue_obj, gen_assets_folder=gen_assets_folder, dry_run=dry_run)

def main(argv):

    parser = argparse.ArgumentParser(description='Validate a map package, or map folders in a map repo PR')
    parser.add_argument('--map-repos-config', type=Path, required=True)
    parser.add_argument('--output-temp-folder', type=Path, required=True)
    parser.add_argument('--gh-repo', type=str, required=True)
    parser.add_argument('--gh-run-id', type=int, required=True)
    parser.add_argument('--gh-issue', type=Path, required=True)
    parser.add_argument('--gh-comment', type=Path, required=False)
    parser.add_argument('--gen-assets-folder', type=Path, required=False)
    parser.add_argument('--dry-run', action='store_true', required=False, help='Skip actions that would modify data on any repos, logging them instead')
    parser.add_argument('--ignore-missing-comment', action='store_true', required=False, help='Ignore if --gh-comment is specified but the file does not exist')
    
    args = parser.parse_args()
    
    # read in the gh-issue json file
    if not args.gh_issue.exists():
        print('ERROR: gh-issue does not exist: {0}'.format(args.gh_issue))
        exit(1)
    with open(args.gh_issue, 'r', encoding='utf-8') as f:
        gh_issue_obj = json.load(f, object_pairs_hook=OrderedDict)
    
    # read in the gh-comment json file (if present)
    gh_comment_obj = None
    if args.gh_comment:
        if args.gh_comment.exists():
            with open(args.gh_comment, 'r', encoding='utf-8') as f:
                gh_comment_obj = json.load(f, object_pairs_hook=OrderedDict)
        elif not args.ignore_missing_comment:
            print('ERROR: gh-comment does not exist: {0}'.format(args.gh_comment))
            exit(1)
    
    map_repo_management_token_provider = None
    if all(x in os.environ for x in ['WZ_GH_APP_MAPREPO_MANAGER_APP_ID', 'WZ_GH_APP_MAPREPO_MANAGER_PRIVATE_KEY_SECRET']):
        map_repo_management_token_provider = WZGithubAppTokenProvider(os.getenv('WZ_GH_APP_MAPREPO_MANAGER_APP_ID'), os.getenv('WZ_GH_APP_MAPREPO_MANAGER_PRIVATE_KEY_SECRET').encode('utf-8'))
    
    result_code = process_map_submission_comment(args.map_repos_config, args.output_temp_folder, args.gh_repo, args.gh_run_id, gh_issue_obj, gh_comment_obj, args.gen_assets_folder, args.dry_run, map_repo_management_token_provider)
    exit(result_code)

if __name__ == "__main__":
    main(sys.argv[1:])
